# 함수 합성 관점에서의 Promise와 모나드 개념

> 함수형 강의 섹션8(비동기: 동시성 프로그래밍 1) 내용 정리 <br/>
> (강의명: 함수형 프로그래밍과 JavaScript ES6+ 유인동 강사님)

함수 합성을 안전하게 하는 모나드

- 함수 합성이란?

```javascript
// f . g
```

어떤 인자가 g 함수에 적용되고 g함수의 실행결과를 f에 그대로 전달해서 f가 결과를 만드는 것을 함수 합성이라고 합니다.

```javascript
// f . g
// f(g(x)); 와 같은 일
```

- 모나드

함수를 안전하게 합성하기 위해 모나드라는 개념이 있다.

그 중에 비동기 상황을 안전하게 합성하는것이 Promise이다.

자바스크립트는 동적타입언어이고 타입을 중심적으로 사고하면서 프로그래밍을 하는 언어는 아니기때문에

모나드, 대수구조 타입들이 잘 묻어나지않는 경향이 있다.

따라서 자바스크립트에서 모나드를 직접적으로 활용한다거나 모나드를 이용한 사용자 정의 객체를 많이 이용하지는 않습니다.

하지만 모나드라는 개념을 알고있으면 함수 합성이나 함수형프로그래밍을 할때 좀더 좋은 사고, 응용력을 가질 수 있기때문에 알고 있으면 좋다.

동적타입언어들은 모나드를 직접적으로 설명하고 있진 않다.

자바스크립트에서는 array나 Promise를 통해 모나드가 무엇인지 알 수 있고 모나드의 함수합성에서의 안전성과 응용력 등을 살펴볼 수 있다.

> “모나드는 함수합성을 안전하게 하는 도구”

`[1]` ← 컨테이너같은것

```javascript
const g = a => a + 1;
const f = a => a * a;

// 연속적으로 g랑 f를 합성함.
log(f(g(1)));//4

// ** 에러발생 : 빈값을 전달하면 에러가 난다
log(f(g()));// NaN
```

f(g(1)); 은 1이라는 값을 가지고 g 함수를 실행하고 그 결과를 f 함수에게 전달한 결과가 유의미한 값이기 때문에

log에게 전달되서 실제로 화면에 출력되기까지 연속적으로 이어져야하며 그것이 정상동작입니다.

그런데

f(g()); 은 g 함수에게 전달되는 값이 어떤게 올지 알수없는 함수형 프로그래밍 세상에서는 인자가 잘못왔을때 로그를 출력하고 싶지않고 외부에 영향을 주고 싶지 않는 효과인데 연속적으로 이어져가서 문제를 일으키기때문에 log(f(g());은 안전하게 합성되었다고 보기 어렵다.

즉, 이 코드는 함수합성이 잘 동작할 수 있는 인자(안전한 인자)만 들어올 수 있는 함수 합성이다.

### 어떤 값이 들어올지 모르는 상황에서는 어떻게 함수합성을 안전하게 할 수 있을까요?

—> <b>모나드</b>

`[]`

모나드는 박스를 가지고 있고 박스안에 실제 효과 혹은 연산에 필요한 재료들을 가지고 있다.

함수합성을 박스가 가지고 있는 메서드를 통해서 함수 합성을 하는데요

map이라는 함수를 통해 함수 합성을 합니다

g와 f를 통해 함수를 합성하려면

`[1].map(g).map(f)` 이렇게 합성합니다.

그런데 여기서 array값은 값들을 다룰때 사용하는 도구이지 사용자 화면에 노출되는 실제 결론은 아니다.

안에 있는 값이 중요하다.

(array인 채로 html에 그대로 출력하진 않으니까)

- 결론

```jsx
[1].map(g).map(f).forEach(r => log(r));

// [1].map(g).map(f) 여기까지가 함수를 합성하고

// forEach를 통해 외부세상에 보여줄 효과를 만듦 (로그를 찍는다거나 HTML에 집어넣는다거나)

결국 위 코드는 아래 코드와 동일하다
log(f(g(1)));
```

### 이렇게 함수합성을 했을때 이점은 무엇인가?

박스[ ]안에 효과가 있는지 없는지에 따라서 함수합성을 안전하게 할 수 있다.

```jsx
[].map(g).map(f).forEach(r => log(r)); // 이렇게하면 실행이안됨 왜냐면 박스안에 값이 유효하지않으니 r => log(r)이 실행이 안되는 것
```

`log(f(g())));`같은 경우는 빈값이 들어와도 강제로 함수 실행이 되면서 효과까지 가버리게 되는데

`[].map(g).map(f).forEach(r => log(r));` 모나드 형태의 array로 map을 통해서 합성했을때는 안전하게 아예 효과를 일으키지 않는 식으로 일어난다.

`[1].map(g).map(f)` 순수함수를 통한 합성까지는 사용자한테 필요한 효과는 없는 상태이다.

`.forEach(r ⇒ log(r));` 그 후에 사용자한테 필요한 효과를 실행

> ***결국 모나드는 사용자한테 필요한 효과를 실행하기전까지 안전하게 함수를 합성해두는 기법이다.***

- 활용

```jsx
[1, 2, 3].map(g).filter(a => a % 2).map(f).forEach(r => log(r)); 
```

### 그렇다면 Promis는 어떠한 관점에서의 함수합성인가?

Promise는 비동기적으로 일어나는 상황을 안전하게 합성하기 위한 도구이다.

```jsx
// Array.of(1) // [1] 어레이 생성
// array는 map을 통해서 함수를 합성
Array.of(1).map(g).map(f).forEach(r => log(r));

// Promise.resolve(1) // Promise {<resolved>: 1} 프로미스객체 생성
// Promise는 then이라는 메소드를 통해 함수를 합성한다.
Promise.resolve(1).then(g).then(f).then(r => log(r));

// Promise.resolve(1) 비동기가 일어나는 상황의 값을 가지고
// then(g).then(f) g와 f를 합성한 후에
// then(r => log(r)); 최종적으로 하고싶은 일을 함

```

- Promise는 비동기상황(대기가 일어난 상황)에서의 합성을 안전하게 하기위한 것이다.

Promise에 안전하지않는 값을 넘으면 부수효과 발생한다. (잘못된 값이 최종효과까지 이어지게된다)

```jsx
Promise.resolve().then(g).then(f).then(r => log(r));// NaN
```

그러나 Promise는 안전한 값이 있거나 없거나의 관점에서 합성을 하는것이 아니라

비동기상황 (대기가 일어난 상황)에서의 합성을 안전하게 하기위한 것이다.

```jsx
new Promise(resolve => setTimeout(() => resolve(2), 100)).then(g).then(f).then(r => log(r));

// new Promise(resolve => setTimeout(() => resolve(2), 100)) 어느시점이후에 실행이 되어 값을 알게되는 효과를 가진 모나드(박스)라고 보면
// 이 함수를 안전하게 합성할 수 있는 시점을 가진 모나드 인거죠.
```

> ***결국 Promise도 array처럼 어떤 특정 상황들을 안전하게 합성하기 위한 하나의 도구이고 이것이 바로 모나드이다.***

### 정리

모나드의 정의가 무엇인지에 대해 너무 집중할 필요는 없다.

`Array.of(1).map(g).map(f).forEach(r => log(r));` 이렇게 map을 통해서 함수를 합성하는 이유가 array 개수가 몇개일지 모르고 array 값이 없을수도 있고 중간에 filter같은 함수를 통해서 좁혀지거나 할수도 있는 그런 상황에서 함수를 연속적으로 안전하게 실행하고 안에 있는 요소들을 가지고 마지막에 최종 효과를 만들기전까지 안전하게 합성하기 위한 도구라고 보시면 된다.

`Promise.resolve(1).then(g).then(f).then(r => log(r));` Promise는 비동기상황에서 적절한 시점에 함수를 평가해서 합성시키기 위한 도구이다.
